解释型语言  
传统语言是编程成机器语言再执行，边编译边执行，  
鸭子类型 - 如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。

强制类型转换  
代码里面转换类似一般都是能看出来的，  
而一些隐藏的发生转换，通常是某些操作产生的副作用。我们叫做强制类型转换  

弱类型，动态语言  
C# 声明变量确认类型，js的一个变量可以保存各种类型。因为可能会发生强制类型转换，所以对于大型程序来说这会是个坑。  

一共7种数据类型  
6种 基本类型 number、boolean、null、undefined、string、symbol  
一个特殊数据类型 object  

引用类型/ 内置值类型 / 抽象数据类型(ADT)  
通过 这门语言(JavaScript) 基本数据类型构建，拥有特定结构，和特定操作的集合。
数据结构与算法 相关。

symbol作为属性名，他的优点是 只能被[]访问，不会出现在for循环中。  

宽松相等 == 允许比较隐式转换后的  
严格相等 === 不允许比较任何强制转换  

## 异步

### 回调的缺点是什么？  

1. 不能第一眼分析出正确的顺序、  
不够直观、不够好！
2. 因为不确定性，需要格外的进行思考！  
ajax就是控制反转，要确认回调可能会发生的问题。所以会写额外的代码。  
设计不够优雅！使你的项目变得笨重。

> 调用回调过早；过晚；调用回调次数过少或过多；吞掉错误和异常，传递环境和参数；

### promise的目的是什么？  
芝士汉堡订单  
控制反转再次反转  

> 和 生成器配合 使得代码健壮性和意图更加清晰
 
### promise的原理是什么？  
Promise 决议  

Promise.all([ .. ]) 数据库并查询  
Promise.race([ .. ]) 竞速 // first([ .. ])  any([ .. ])  last([ .. ])    
Promise.map([ .. ]) 遍历    

### 为什么叫generator 生成器 ？  
generator 发电机    
yield  生产  
next 下一个  

### 为什么会有生成器？  
通过 yield 和 next(..) 建立的双向消息，传递控制反转再反转  
注意力转移使得代码能更加清晰表达意图  
并不是阻塞，错误处理正常报错  

### async 函数 与 生成器(generator) 有什么区别？

生成器(generator)是迭代器的发展  

async 函数 是 生成器(generator)与promise的组合  
yield 出 Promise await 等待决议  

这也是 ES6 最屌的地方就是生成器(generator) 与 promise的组合。  
使得代码健壮性和意图更加清晰！  

## 面向对象

### JavaScript不能用多态吗？

一谈到多态，我们就会想到继承。
其实多态是一种思想、

Java为了消除耦合（不变的部分隔离出来、可变的部分各自封装起来  
因为Java强类型语言特性，所以面向对象方式通常被设计为可以向上转型  
这样既符合我们思维模式，也消除类型之间的耦合关系。  

但是JavaScript里多此一举，因为 JavaScript 对象与生俱来多态性。  
所以不能这样(向上转型)设计多态。

还是先把程序中相同的部分抽象出来

“做什么”和“怎么去做”是可以分开的。

当我们对一些函数发出“调用”的消息时，这些函数会返回不同的执行结果，  
这是“多态性”的一种体现！

不要为了多态而多态。

### 广义的封装

类似于，控制反转。  
封装变化，耦合性  
将稳定的，与容易变化的分隔开来、  
API不影响其他程序。  

### this

对象
	对象方法
	会丢失
函数
	不为对象属性方法调用时，词法作用域。
构造器
	构造器里的 this 就指向返回的这个对象
	function a() {this.c = 111;}
	var aa = new a();
	console.log(aa.c);// 11
call、apply 和 bind;
	函数式编程非常有用

### 请用自己的话叙述一遍面向对象五大基本原则。


