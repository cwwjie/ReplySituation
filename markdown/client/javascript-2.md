## 问题思考
严格模式有什么目的？
什么是数据类型？为什么会有数据类型？JavaScript有多少种数据类型？

## 语言相关

解释型语言  
传统语言是编程成机器语言再执行，边编译边执行，  
鸭子类型 - 如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。

强制类型转换  
代码里面转换类似一般都是能看出来的，  
而一些隐藏的发生转换，通常是某些操作产生的副作用。我们叫做强制类型转换  

弱类型，动态语言  
C# 声明变量确认类型，js的一个变量可以保存各种类型。因为可能会发生强制类型转换，所以对于大型程序来说这会是个坑。  

一共7种数据类型  
6种 基本类型 number、boolean、null、undefined、string、symbol  
一个特殊数据类型 object  

引用类型/ 内置值类型 / 抽象数据类型(ADT)  
通过 这门语言(JavaScript) 基本数据类型构建，拥有特定结构，和特定操作的集合。
数据结构与算法 相关。

symbol作为属性名，他的优点是 只能被[]访问，不会出现在for循环中。  

宽松相等 == 允许比较隐式转换后的  
严格相等 === 不允许比较任何强制转换  

typeof 是判断什么的？

值类型 返回字符串  
typeof null 返回 object 是个不会修复的BUG;  

## 异步

### 回调的缺点是什么？  

1. 不能第一眼分析出正确的顺序、  
不够直观、不够好！
2. 因为不确定性，需要格外的进行思考！  
ajax就是控制反转，要确认回调可能会发生的问题。所以会写额外的代码。  
设计不够优雅！使你的项目变得笨重。

> 调用回调过早；过晚；调用回调次数过少或过多；吞掉错误和异常，传递环境和参数；

### promise的目的是什么？  
芝士汉堡订单  
控制反转再次反转  

> 和 生成器配合 使得代码健壮性和意图更加清晰
 
### promise的原理是什么？  
Promise 决议  

Promise.all([ .. ]) 数据库并查询  
Promise.race([ .. ]) 竞速 // first([ .. ])  any([ .. ])  last([ .. ])    
Promise.map([ .. ]) 遍历    

### 为什么叫generator 生成器 ？  
generator 发电机    
yield  生产  
next 下一个  

### 为什么会有生成器？  
通过 yield 和 next(..) 建立的双向消息，传递控制反转再反转  
注意力转移使得代码能更加清晰表达意图  
并不是阻塞，错误处理正常报错  

### async 函数 与 生成器(generator) 有什么区别？

生成器(generator)是迭代器的发展  

async 函数 是 生成器(generator)与promise的组合  
yield 出 Promise await 等待决议  

这也是 ES6 最屌的地方就是生成器(generator) 与 promise的组合。  
使得代码健壮性和意图更加清晰！  

## 面向对象

### JavaScript不能用多态吗？

一谈到多态，我们就会想到继承。

其实多态是一种思想、

同一个信息被不同的对象接收到时可能产生不同的行为，这就是多态性。  

Java为了消除耦合（不变的部分隔离出来、可变的部分各自封装起来  
因为Java强类型语言特性，所以面向对象方式通常被设计为可以向上转型  
这样既符合我们思维模式，也消除类型之间的耦合关系。  

但是JavaScript里多此一举，因为 JavaScript 对象与生俱来多态性。  
所以不能这样(向上转型)设计多态。

还是先把程序中相同的部分抽象出来

“做什么”和“怎么去做”是可以分开的。

当我们对一些函数发出“调用”的消息时，这些函数会返回不同的执行结果，  
这是“多态性”的一种体现！

不要为了多态而多态。

### 广义的封装

类似于，控制反转。  
封装变化，耦合性  
将稳定的，与容易变化的分隔开来、  
API不影响其他程序。  

### this

* 对象  
	* 对象方法
	* 会丢失
* 函数
	* 不为对象属性方法调用时，词法作用域。
* 构造器  
	* 构造器里的 this 就指向返回的这个对象
	* function a() {this.c = 111;}  
	var aa = new a();  
	console.log(aa.c); // 11  
* call、apply 和 bind;
	* 函数式编程非常有用

### 请用自己的话叙述一遍面向对象设计的三个基本要素，五大基本原则。
三个基本要素

* 封装就是只需要知道这个类是做什么？而不需要关心具体实现！  
* 继承是比较容易理解的，难的是抽象、 JavaScript有原型继承。
* 多态性，JavaScript与生俱来就是多态。

五大基本原则

1. 单一职责原则,一个对象只做一件事、如果一个对象做了很多事，那么你的代码是耦合的非常高的。你需要抽象。
2. 开放封闭原则, 就是当你需要拓展的时候，不需要改代码写if判断。
3. 里氏替换原则,
	* 继承相关,正方形不是长方形,鸵鸟不是鸟,
	* 面向对象的设计关注的是对象的行为，只有行为一致的对象才能抽象出一个类来。
	* 行为也是与需求互相挂钩的，只有满足具体环境鸵鸟才是鸟。
4. 依赖倒置原则
	* 高层模块不应该依赖于低层模块
		* 例如：登录(高层模块);不必依赖于Google User API(低层模块);
		* 应该将依赖(Google User API)提供给高层模块(登录)
		* 而不是高层模块(登录)去获取依赖Google User API;
	* 依赖倒置原则和依赖注入都是关注依赖，并且都是用于反转。
		* 依赖注入是控制反转的一个特殊形式。
	* 依赖倒置原则没有关注组件如何获取依赖，而是只关注高层模块如何从低层模块里解耦出来。
	* 从低层里定义，反转到高层里定义
5. 接口隔离原则 
	* 具有单一职责的对象，转化到一个具有公共接口的对象。

理解思想就好，不要生搬硬套。我们的目标是高内聚低耦合！

### 请用你自己的话叙述一遍 [高内聚低耦合](https://baike.baidu.com/item/%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88/5227009?fr=aladdin)

* 耦合模块
	* 尽量不要，一个模块的内容不通过接口访问另外一个模块内容。
	* 慎重，多个模块访问一组公共数据。
	* 少用，一个模块控制了另外一个模块的功能，（比如这个登录模块控制下一步。
	* 没办法，模块与模块之间互相传递(标记/数据项参数)，（比如登录成功返回一个true。
	* 最好，两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。
* 功能内聚
	* 一个模块各元素之间没有任何联系，只是巧合放置在了一起
	* 通过逻辑联系在一个模块(通过参数if判断)
	* 把一个时间段内要做的事情组合在一个模块（
	* 执行的过程聚合在一个模块，（比如，调用前面的构件或操作之后，马上调用后面的构件或操作
	* 一个模块通过数据聚合在一起
	* 一个模块各个元素只完成一个功能



### 请用你自己的话叙述一遍 ES6 Class

1. 需要 new 才能用。
2. 是个语法糖，本质是
	* 子类.[[prototype]] = 父类
	* 子类.prototype.[[prototype]] = 父类.prototype
3. constructor 里面的 this 绑定的是实例上的。super 必须声明。
4. super作为对象是父类的 prototype，静态是为父类。
5. 实例不能调用静态方法。
6. Class里面的方法实际是在 prototype 里面，被设置成为不能枚举。





